# گزارش آزمایش ۸ آزمایشگاه مهندسی نرم‌افزار

## بخش اول - پیاده‌سازی الگوی `Adapter`

### انتخاب نوع `Adapter`

من الگو را به شکل `Object Scope` پیاده‌سازی کردم. دلیل استفاده: با پیاده‌سازی به این شیوه
اصل composition رعایت می‌شد و `Adapter` تنها یک instance از کلاس کتابخانه نگه می‌دارد و با
اصول طراحی شی‌گرا همخوانی دارد.

دلیل عدم استفاده از `Class Scope`: در صورت پیاده‌سازی به این روش باید کلاس `Adapter` هم از
اینترفیس `MyGraph` ارث‌بری کند و هم از کلاس متناظر در کتابخانه ارث‌بری کند. با توجه به اینکه
این نوع ارث‌بری در جاوا وجود ندارد، پیاده‌سازی به این روش امکان‌پذیر نبود.

### نحوه پیاده‌سازی الگو

برای پیاده‌سازی الگو کافی است ابتدا توابع استفاده شده از کتابخانه را در یک اینترفیس
تعریف کنیم. سپس در کد‌های مربوطه به جز جایی که instantiate می‌کنیم، از اینترفیس تعریف
شده (به نام `MyGraph`) استفاده می‌کنیم. حال یک کلاس `JungAdapter` می‌سازیم که در آن یک شی
از کتابخانه مربوطه instantiate می‌کنیم و توابع تعریف شده در اینترفیس را پیاده‌سازی می‌کنیم.
حال در کد `Main` به جای ساختن شی کتابخانه یک شی از کلاس `Adapter` می‌سازیم.

## بخش دوم - تغییر کتابخانه

### گزارش تغییر کتابخانه

برای تغییر کتابخانه با توجه به تغییرات بخش قبلی کافی است، یک `Adapter` جدید برای این
کتابخانه بنویسیم. نام آن را `JGraphTAdapter` می‌گذاریم. همچنین حالا باید توابع اینترفیس
`MyGraph` را برای آن پیاده‌سازی کنیم و یک شی گراف ایجاد کنیم. با توجه به شیوه استفاده
از گراف در این کد از کلاس `DefaultUndirectedGraph` استفاده می‌کنیم. همچنین برای پیدا کردن
همسایه‌های یک راس از `Graphs.neighborListOf` استفاده می‌کنیم.

### تغییرات ناشی از تغییر کتابخانه

حال که `Adapter` جدید را ساختیم کافی است در کلاس `Main` به جای `JungAdapter` از
‍`JGraphTAdapter` استفاده کنیم.

## بخش سوم - تحلیل الگوی استراتژی

### استفاده از این الگو به چه علتی قابل قبول است؟

### روش تحقق این الگو را به صورت خلاصه توضیح دهید
